#This is essentially the same code derived from the jupyter notebook for calculating entropic contributions from
#the W-SASA method

import os
import sys
import glob
import shutil
import tempfile
import subprocess
import json
import pandas as pd
import numpy as np
import mdtraj
import parmed as pmd
import freesasa

sys.setrecursionlimit(15000000)

def parse_filter_residues(filter_residues):
    """
    Convert input list of residue names into an mdtraj filter which will 
    select all residues not match an entry in the input list.
    
    Parameters
    ----------
    filter_residues : list
        Residue codes to be combined into a exclusion filter.

    Returns
    -------
    str
        Selection text in mdtraj format selecting everything that does not 
        match input residue names.
        
    """

    # TODO: Check the escape character for + ions

    selection_text = '! ('
    selection_text += ' or '.join(['(resname =~ {:s})'.format(x) for x in filter_residues])
    selection_text += ')'

    return selection_text

def create_freesasa_section_text(res_name, res_atom_to_type, sasa_atom_params):
    """
    Create text to add to freesasa configuration file to incorporate new residue. 
    
    Parameters
    ----------
    res_name : str
        Residue codes to be combined into a exclusion filter.
    res_atom_to_type : dict
        Provides mapping from atom name to atom type.
    sasa_atom_params: dict
        Maps atom type to properties needed by freesasa (radius and polarity).

    Returns
    -------
    atom_type_section : str
        Text to be added to freesasa config file atom type section.
    residue_section : str
        Text to be added to freesasa config file residue section.
        
    """

    # Create lines for atom type section of format:
    # atom_type residue polarity
    atom_type_section = ''

    atom_types = set(res_atom_to_type.values())

    for atom_type in atom_types:

        atom_line = '{:s} {:.2f} {:s}\n'.format(atom_type,
                                                sasa_atom_params[atom_type]['radius'],
                                                sasa_atom_params[atom_type]['polarity'])
        atom_type_section += atom_line

    # Create lines for residue section of format:
    # residue_name atom_name atom_type
    residue_section = ''

    for atom_name, atom_type in res_atom_to_type.items():

        residue_line = '{:s} {:s} {:s}\n'.format(res_name,
                                                 atom_name,
                                                 atom_type)

        residue_section += residue_line

    return atom_type_section, residue_section

def update_freesasa_config_file(res_name, res_atom_to_type,
                                params, orig_filname, new_filname):
    """
    Create a new freesasa config file that adds specified residue to the 
    existing copy. 
    
    Parameters
    ----------
    res_name : str
        Residue codes to be combined into a exclusion filter.
    res_atom_to_type : dict
        Provides mapping from atom name to atom type.
    params: dict
        Maps atom type to properties needed by freesasa (radius and polarity).
    orig_filename: str
        Filename for the original freesasa config file.
    new_filename: str
        Filename to be used for the updated freesasa config file.
    
    """

    (new_atom_types,
     new_residue) = create_freesasa_section_text(res_name,
                                                 res_atom_to_type,
                                                 params)

    out_file = open(new_filname, 'w')

    with open(orig_filname) as input_config:

        for next_text in input_config:

            if next_text.startswith('# extra'):
                next_text += new_atom_types

            out_file.write(next_text)

    out_file.write('\n')
    out_file.write(new_residue)

    out_file.close()

    return

def atom_contribution_nm(atom_type, sas, params):
    """
    Calculate the contribution for a given atom to the estimation of the 
    configurational entropy that would be computed via normal mode analysis.
    Formula from:
        Wang, J., & Hou, T. (2012). Develop and Test a Solvent Accessible 
        Surface Area-Based Model in Conformational Entropy Calculations. 
        Journal of Chemical Information and Modeling, 
        52(5), 1199â€“1212. http://doi.org/10.1021/ci300064d
    
    contribution = weight * (sas + k * bsa)
    bsa = (4 * pi * (radius + probe_radius)^2) - sas
    
    sas = solvent accessible surface
    bsa = buried surface area
    
    Note: Units are cal/mol (NOT kcal/mol)
    
    Parameters
    ----------
    atom_type : str
        Atom type of selected atom.
    sas: float
        Solvent accessible surface area for selected atom.
    params : dict
        Dictionary containing sas to normal mode configurational entropy 
        estimate parameters.
             
    Returns
    -------   
    float
        Atomic contribution to the configurational entropy
        
    """

    probe_radius = params['rprobe']
    atom_type_info = params['params'][atom_type]
    k = params['k']

    total_atom_surf = 4 * np.pi * (atom_type_info['radius'] + probe_radius)**2
    bsa = total_atom_surf - sas

    return atom_type_info['weight'] * (sas + k * bsa)

def create_subsection_pdb(traj, frame, atom_list, pdb_filename):
    """
    Create a PDB containing the coordiates of the selected atoms and 
    given frame from a mdtraj.Trajectory 
    
    Parameters
    ----------
    traj : mdtraj.Trajectory
        Trajectory providing sources of coordinates.
    frame: int
        Frame to select.
    atom_list : list
        List of atom indices to include in output PDB.
    pdb_filename : str 
        Filename for output PDB
    
    """

    frame = traj.slice(frame_ndx)
    frame.atom_slice(atom_list, inplace=True)
    frame.save(pdb_filename)

    return


# In[101]:


nm_param_filename = 'share-data/sasa-nmode-params-wang2012.json'
calc_config_filename = 'data/input-stuff.json'

freesasa_template_filename = 'share-data/amber_config.txt'

init_solvated_topology_filename = 'fouad.prmtop'
init_ligand_topology_filename = 'lig.prmtop'
trajectory_filename = 'com.dcd'
frames_to_analyse = range(0,100,25)


# In[102]:


sasa_nm_params = json.load(open(nm_param_filename,'r'))
system_config = json.load(open(calc_config_filename,'r'))

complex_selection = parse_filter_residues(system_config['filter_residues'])
temperature = system_config['temperature']


# In[103]:


tmp_dir = tempfile.mkdtemp()

# MDtraj needs Amber topologies to have official file extensions
top_filename = os.path.join(tmp_dir, 'fouad.prmtop')
lig_top_filename = os.path.join(tmp_dir, 'lig.prmtop')

shutil.copyfile(init_solvated_topology_filename, top_filename)
shutil.copyfile(init_ligand_topology_filename, lig_top_filename);

# May need validation:
# Ensure one residue in ligand
# Need cofactors to be added as well as ligands where appropriate                        
com_top = pmd.load_file(top_filename)
lig_top = pmd.load_file(lig_top_filename)

system_sasa_config = os.path.join(tmp_dir, 'sasa-config.txt')


# In[104]:


lig_atom_to_type = dict(zip(lig_top.parm_data['ATOM_NAME'], lig_top.parm_data['AMBER_ATOM_TYPE']))
lig_name = lig_top.parm_data['RESIDUE_LABEL'][0]

# TODO: This should be default - allow user input (i.e. for peptide ligands)
lig_selection = 'resname {:s}'.format(lig_name)
receptor_selection = '({:s}) and not ({:s})'.format(complex_selection, lig_selection)

traj = mdtraj.load(trajectory_filename, top=top_filename)

atom_selections = {
    'complex' : traj.top.select(complex_selection),
    'ligand': traj.top.select(lig_selection),
    'receptor': traj.top.select(receptor_selection),
}


# In[105]:


update_freesasa_config_file(lig_name, lig_atom_to_type, sasa_nm_params['params'],
                            freesasa_template_filename, system_sasa_config)

classifier = freesasa.Classifier(bytes(system_sasa_config, 'utf-8'))

structure_array_options = {
    'hetatm' : True,
    'hydrogen' : True,
    #'separate-chains' : False,
    'separate-models' : True
}


# In[106]:


tmp_pdb_file = os.path.join(tmp_dir,'tmp.pdb')

results = {}

time_steps = [str(x) for x in frames_to_analyse]

for component, atom_list in atom_selections.items():

    n_atoms = len(atom_list)
    tmp_results = []

    for frame_ndx in frames_to_analyse:

        create_subsection_pdb(traj, frame_ndx, atom_list, tmp_pdb_file)

        structure = freesasa.Structure(bytes(tmp_pdb_file, 'utf-8'),
                                       options=structure_array_options,
                                       classifier=classifier)
        result = freesasa.calc(structure)
        atom_areas = [result.atomArea(ndx) for ndx in range(n_atoms)]
        tmp_results.append(atom_areas)



    results[component] = pd.DataFrame(tmp_results).T
    results[component].columns = time_steps

    results[component]['average'] = results[component].mean(axis=1)

    results[component]['residue'] = [traj.top.atom(x).residue.name for x in atom_list]
    results[component]['atom_name'] = [com_top.parm_data['ATOM_NAME'][x] for x in atom_list]
    results[component]['atom_type'] = [com_top.parm_data['AMBER_ATOM_TYPE'][x] for x in atom_list]


# In[107]:


# Calculate configurational entropy, s, for each component
s = {}                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  1,1           Top
